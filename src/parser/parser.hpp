//
// Created by dte on 2/24/2025.
//
#pragma once
#include "enums/token_type.hpp"
#include <vector>
#include <jit/jit.hpp>
using namespace enums;
extern std::vector<iota::token> tokens;

// namespace parser
// {
typedef enums::token_type SYMBOL;
#include "ilc/include/ilc.hpp"

BEGIN_ILC_CODEGEN

namespace parser
{
    enum state_t
    {
        STATEMENT,
        DEFAULT = STATEMENT,
        VARIABLE,
        CONSTANT
    };

    state_t state = STATEMENT;
    std::string id,type,value;
}

#define EXPECTED(ITEM) []() \
        {\
            fmt::println(stderr, "syntax error: expected {} found {} @{} at {}", ITEM, tokens[ILC::offset].value,  (int)tokens[ILC::offset].type ,tokens[ILC::offset-1].get_location_string()); \
        }

BEGIN_PRODUCTION(PRODUCTION_NIMPORT_STAT)
    REQUIRE_TERMINAL(TKEYWORD_IMPORT)
    REQUIRE_TERMINAL_CALLBACK(TBRACES_OPEN, EXPECTED("{"))
    REQUIRE_NON_TERMINAL_CALLBACK(NSECOND_PRIORITY_RHS_VAL, EXPECTED("value"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NIF)
    REQUIRE_TERMINAL(TKEYWORD_IF)
    REQUIRE_TERMINAL_CALLBACK(TPARENTHESIS_OPEN, EXPECTED("("))
    REQUIRE_NON_TERMINAL_CALLBACK(NVAL, EXPECTED("value"))
    REQUIRE_TERMINAL_CALLBACK(TPARENTHESIS_CLOSE, EXPECTED(")"))
    REQUIRE_TERMINAL_CALLBACK(TBRACES_OPEN, EXPECTED("{"))
    REQUIRE_NON_TERMINAL_CALLBACK(NSTAT, EXPECTED("statement"))
    REQUIRE_TERMINAL_CALLBACK(TBRACES_CLOSE, EXPECTED("}"))
    while (TRY_REQUIRE_TERMINAL(TKEYWORD_ELSE))
    {
        if (TRY_REQUIRE_TERMINAL(TKEYWORD_IF))
        {
            REQUIRE_TERMINAL_CALLBACK(TPARENTHESIS_OPEN, EXPECTED("("))
            REQUIRE_NON_TERMINAL_CALLBACK(NVAL, EXPECTED("value"))
            REQUIRE_TERMINAL_CALLBACK(TPARENTHESIS_CLOSE, EXPECTED(")"))
            REQUIRE_TERMINAL_CALLBACK(TBRACES_OPEN, EXPECTED("{"))
            REQUIRE_NON_TERMINAL_CALLBACK(NSTAT, EXPECTED("statement"))
            REQUIRE_TERMINAL_CALLBACK(TBRACES_CLOSE, EXPECTED("}"))
        }
        else
        {
            REQUIRE_TERMINAL_CALLBACK(TBRACES_OPEN, EXPECTED("{"))
            REQUIRE_NON_TERMINAL_CALLBACK(NSTAT, EXPECTED("statement"))
            REQUIRE_TERMINAL_CALLBACK(TBRACES_CLOSE, EXPECTED("}"))
            break;
        }
    }
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NSUFFIX_FUNCTION_CALL)
    REQUIRE_TERMINAL(TPARENTHESIS_OPEN)
    while (TRY_REQUIRE_NON_TERMINAL(NVAL))
    {
        if (not TRY_REQUIRE_TERMINAL(TCOMMA))
        {
            break;
        }
    }
    REQUIRE_TERMINAL_CALLBACK(TPARENTHESIS_CLOSE, EXPECTED(")"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NFUNCTION)
    REQUIRE_TERMINAL(TKEYWORD_FUNCTION)
    // provides parser::id
    REQUIRE_NON_TERMINAL_CALLBACK(NID, EXPECTED("identifier"))
    REQUIRE_TERMINAL_CALLBACK(TPARENTHESIS_OPEN, EXPECTED("("))
    do
    {
        if (TRY_REQUIRE_NON_TERMINAL(NID))
        {
            REQUIRE_TERMINAL_CALLBACK(TCOLON, EXPECTED(":"))
            REQUIRE_NON_TERMINAL_CALLBACK(NTYPE, EXPECTED("TYPE"))
        }
    }
    while (TRY_REQUIRE_TERMINAL(TCOMMA));
    REQUIRE_TERMINAL_CALLBACK(TPARENTHESIS_CLOSE, EXPECTED(")"))
    if (TRY_REQUIRE_TERMINAL(TCOLON))
    {
        REQUIRE_NON_TERMINAL_CALLBACK(NTYPE, EXPECTED("TYPE"))
    }
    REQUIRE_TERMINAL_CALLBACK(TBRACES_OPEN, EXPECTED("{"))
    while (TRY_REQUIRE_NON_TERMINAL(NSTAT))
    {
    }
    TRY_REQUIRE_NON_TERMINAL(NRETURN);
    REQUIRE_TERMINAL_CALLBACK(TBRACES_CLOSE, EXPECTED("}"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NFOR)
    REQUIRE_TERMINAL(TKEYWORD_FOR)
    REQUIRE_TERMINAL_CALLBACK(TPARENTHESIS_OPEN, EXPECTED("("))
    REQUIRE_NON_TERMINAL_CALLBACK(NSTAT, EXPECTED("statement"))
    REQUIRE_TERMINAL_CALLBACK(TSEMICOLON, EXPECTED(";"))
    REQUIRE_NON_TERMINAL_CALLBACK(NVAL, EXPECTED("value"))
    REQUIRE_TERMINAL_CALLBACK(TSEMICOLON, EXPECTED(";"))
    if (not(TRY_REQUIRE_NON_TERMINAL(NVAL) or TRY_REQUIRE_NON_TERMINAL(NSTAT)))
    {
        EXPECTED("statement or value")();
    }
    REQUIRE_TERMINAL_CALLBACK(TPARENTHESIS_CLOSE, EXPECTED(")"))
    REQUIRE_TERMINAL_CALLBACK(TBRACES_OPEN, EXPECTED("{"))
    while (TRY_REQUIRE_NON_TERMINAL(NSTAT))
    {
    }
    REQUIRE_TERMINAL_CALLBACK(TBRACES_CLOSE, EXPECTED("}"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NWHILE)
    REQUIRE_TERMINAL(TKEYWORD_WHILE)
    REQUIRE_TERMINAL_CALLBACK(TPARENTHESIS_OPEN, EXPECTED("("))
    REQUIRE_NON_TERMINAL_CALLBACK(NVAL, EXPECTED("value"))
    REQUIRE_TERMINAL_CALLBACK(TPARENTHESIS_CLOSE, EXPECTED(")"))
    REQUIRE_TERMINAL_CALLBACK(TBRACES_OPEN, EXPECTED("{"))
    while (TRY_REQUIRE_NON_TERMINAL(NSTAT))
    {
    }
    REQUIRE_TERMINAL_CALLBACK(TBRACES_CLOSE, EXPECTED("}"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_PREFIX_VAL)
    REQUIRE_NON_TERMINAL(NSINGLE_VAL)
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_TIMES_VALUE)
    REQUIRE_TERMINAL(TTIMES)
    REQUIRE_NON_TERMINAL_CALLBACK(NFIRST_PRIORITY_RHS_VAL, EXPECTED("value"))
    jit::insn_mult();
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_SLASH_VALUE)
    REQUIRE_TERMINAL(TSLASH)
    REQUIRE_NON_TERMINAL_CALLBACK(NFIRST_PRIORITY_RHS_VAL, EXPECTED("value"))
    jit::insn_div();
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_PLUS_VAL)
    REQUIRE_TERMINAL(TPLUS)
    REQUIRE_NON_TERMINAL_CALLBACK(NSECOND_PRIORITY_RHS_VAL, EXPECTED("value"))
    jit::insn_add();
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_MINUS_VALUE)
    REQUIRE_TERMINAL(TMINUS)
    REQUIRE_NON_TERMINAL_CALLBACK(NTHIRD_PRIORITY_RHS_VAL, EXPECTED("value"))
    jit::insn_sub();
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_GREATER_VALUE)
    REQUIRE_TERMINAL(TGREATER)
    REQUIRE_NON_TERMINAL_CALLBACK(NFOURTH_PRIORITY_RHS_VAL, EXPECTED("value"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_GREATER_OR_EQUAL_VALUE)
    REQUIRE_TERMINAL(TGREATER_OR_EQUAL)
    REQUIRE_NON_TERMINAL_CALLBACK(NFOURTH_PRIORITY_RHS_VAL, EXPECTED("value"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_LOWER_VALUE)
    REQUIRE_TERMINAL(TLOWER)
    REQUIRE_NON_TERMINAL_CALLBACK(NFOURTH_PRIORITY_RHS_VAL, EXPECTED("value"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_LOWER_OR_EQUAL_VALUE)
    REQUIRE_TERMINAL(TLOWER_OR_EQUAL)
    REQUIRE_NON_TERMINAL_CALLBACK(NFOURTH_PRIORITY_RHS_VAL, EXPECTED("value"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_EQUAL_VALUE)
    REQUIRE_TERMINAL(TEQUAL)
    REQUIRE_NON_TERMINAL_CALLBACK(NFIFTH_PRIORITY_RHS_VAL, EXPECTED("value"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_NOT_EQUAL_VALUE)
    REQUIRE_TERMINAL(TNOT_EQUAL)
    REQUIRE_NON_TERMINAL_CALLBACK(NFIFTH_PRIORITY_RHS_VAL, EXPECTED("value"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_AND_VALUE)
    REQUIRE_TERMINAL(TAND)
    REQUIRE_NON_TERMINAL_CALLBACK(NSIXTH_PRIORITY_RHS_VAL, EXPECTED("value"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_OR_VALUE)
    REQUIRE_TERMINAL(TOR)
    REQUIRE_NON_TERMINAL_CALLBACK(NSEVENTH_PRIORITY_RHS_VAL, EXPECTED("value"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_AS_NUM)
    bool negative = false;
    if (TRY_REQUIRE_TERMINAL(TMINUS))
        negative = true;
    if (TRY_REQUIRE_TERMINAL(TPLUS))
        negative = false;
    using namespace ILC;
    using namespace jit;
    if (not TRY_REQUIRE_TERMINAL(TINT_NUM))
    {
        REQUIRE_TERMINAL(TDOUBLE_NUM)
        stack.emplace(builder()->f64(strtod(tokens[offset - 1].value.c_str(), nullptr)));
    } else
    {
        stack.emplace(builder()->i32(strtol(tokens[offset - 1].value.c_str(), nullptr, 10)));
    }
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_AS_CHAR_ARRAY)
    REQUIRE_TERMINAL(TCHAR_ARRAY)
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_NOT_VAL)
    REQUIRE_TERMINAL(TNOT)
    REQUIRE_NON_TERMINAL_CALLBACK(NVAL, EXPECTED("value"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NSUFFIX_VAL_NTERNARY)
    REQUIRE_TERMINAL(TQUESTION)
    REQUIRE_NON_TERMINAL_CALLBACK(NVAL, EXPECTED("value"))
    REQUIRE_TERMINAL(TCOLON)
    REQUIRE_NON_TERMINAL_CALLBACK(NVAL, EXPECTED("value"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_WITH_PARENTHESIS)
    REQUIRE_TERMINAL(TPARENTHESIS_OPEN)
    REQUIRE_NON_TERMINAL_CALLBACK(NVAL, EXPECTED("value"))
    REQUIRE_TERMINAL_CALLBACK(TPARENTHESIS_CLOSE, EXPECTED(")"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_AS_ID)
    REQUIRE_NON_TERMINAL(NID)
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVAL_BOOLEAN)
    if (not TRY_REQUIRE_TERMINAL(TKEYWORD_TRUE))
        REQUIRE_TERMINAL(TKEYWORD_FALSE)
    using namespace ILC;
    using namespace jit;
    stack.emplace(builder()->i8(static_cast<char>(chain[offset - 1] == TKEYWORD_TRUE)));
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NTYPE)
    if (not(TRY_REQUIRE_TERMINAL(TKEYWORD_MUTABLE) or TRY_REQUIRE_NON_TERMINAL(NID) or
        TRY_REQUIRE_TERMINAL(TKEYWORD_NUMBER) or TRY_REQUIRE_TERMINAL(TKEYWORD_STRING) or TRY_REQUIRE_TERMINAL(
            TKEYWORD_ANY)))
    {
        ROLLBACK_PRODUCTION()
    }
    parser::type += tokens[ILC::offset-1].value;
    if (TRY_REQUIRE_TERMINAL(TLOWER))
    {
        parser::type += "<";
        REQUIRE_NON_TERMINAL(NTYPE)
        REQUIRE_TERMINAL_CALLBACK(TGREATER, EXPECTED(">"))
        parser::type += ">";
    }
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NVARIABLE_DEFINITION)
    parser::state = parser::VARIABLE;
    REQUIRE_TERMINAL(TKEYWORD_VAR)
    REQUIRE_NON_TERMINAL_CALLBACK(NSUFFIX_VAR_CONST_DEFINITION, EXPECTED("variable like definition"))
    parser::state = parser::DEFAULT;
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NCONST_DEFINITION)
    parser::state = parser::VARIABLE;
    REQUIRE_TERMINAL(TKEYWORD_CONST)
    REQUIRE_NON_TERMINAL_CALLBACK(NSUFFIX_VAR_CONST_DEFINITION, EXPECTED("variable like definition"))
    parser::state = parser::DEFAULT;
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NSUFFIX_VAR_CONST_DEFINITION)
    // provides parser::id
    REQUIRE_NON_TERMINAL_CALLBACK(NID, EXPECTED("identifier"))
    if (TRY_REQUIRE_TERMINAL(TCOLON))
    {
        parser::type.clear();
        REQUIRE_NON_TERMINAL_CALLBACK(NTYPE, EXPECTED("type"))
    } else
    {
        parser::type = "<unspecified>";
    }
    REQUIRE_TERMINAL_CALLBACK(TEQU, EXPECTED("="))
    REQUIRE_NON_TERMINAL_CALLBACK(NVAL, EXPECTED("value"))
    using namespace jit;
    using namespace parser;
    const auto value = stack.top();
    stack.pop();
    switch (state)
    {
        case VARIABLE:
            scope().variables[id] = value;
        break;
        case CONSTANT:
            scope().constants[id] = value;
        break;
        default: ;
    }
    fmt::println("{} : {}", parser::id, parser::type);
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NASGN_SUFFIX)
    if (not(TRY_REQUIRE_TERMINAL(TEQU) or TRY_REQUIRE_TERMINAL(TPLUS_EQU) or TRY_REQUIRE_TERMINAL(TMINUS_EQU) or
        TRY_REQUIRE_TERMINAL(TTIMES_EQU) or TRY_REQUIRE_TERMINAL(TSLASH_EQU) or TRY_REQUIRE_TERMINAL(TMINUS_EQU)))
    {
        ROLLBACK_PRODUCTION()
    }
    REQUIRE_NON_TERMINAL_CALLBACK(NVAL, EXPECTED("value"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NYIELD)
    REQUIRE_TERMINAL(TKEYWORD_YIELD)
    REQUIRE_NON_TERMINAL_CALLBACK(NVAL, EXPECTED("value"))
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NRETURN)
    REQUIRE_TERMINAL(TKEYWORD_RETURN)
    if (TRY_REQUIRE_NON_TERMINAL(NVAL))
    {
    }
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_ENDLESS_SUFFIXES)
    while (TRY_REQUIRE_NON_TERMINAL(NSUFIXED_VAL))
    {
    }
END_PRODUCTION

BEGIN_PRODUCTION(META_PRODUCTION_STAT)
    while (TRY_REQUIRE_NON_TERMINAL(NSTAT))
    {
    }
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NSTAT_FROM_VAL_or_ASGN_or_OR_or_AND)
    bool instruction_invoked = TRY_REQUIRE_TERMINAL(TPLUS_PLUS) or TRY_REQUIRE_TERMINAL(TMINUS_MINUS);
    REQUIRE_NON_TERMINAL(NID)
    instruction_invoked = instruction_invoked or TRY_REQUIRE_NON_TERMINAL(NSUFFIX_FUNCTION_CALL) or
        TRY_REQUIRE_TERMINAL(TPLUS_PLUS) or TRY_REQUIRE_TERMINAL(TMINUS_MINUS) or TRY_REQUIRE_NON_TERMINAL(NSUFFIX_ASGN)
        or TRY_REQUIRE_NON_TERMINAL(NSUFFIX_VAL_NTERNARY) or TRY_REQUIRE_NON_TERMINAL(NOR_VAL) or
        TRY_REQUIRE_NON_TERMINAL(NAND_VAL);
    if (not instruction_invoked)
    {
        EXPECTED("statement")();
        ROLLBACK_PRODUCTION();
    }
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NSINGLE_VAL)
    const bool pre_buffer = TRY_REQUIRE_TERMINAL(TPLUS_PLUS) or TRY_REQUIRE_TERMINAL(TMINUS_MINUS);
    REQUIRE_NON_TERMINAL(NSINGLE_VAL_PREDICATE)
    if (not pre_buffer)
        TRY_REQUIRE_TERMINAL(TPLUS_PLUS) or TRY_REQUIRE_TERMINAL(TMINUS_MINUS);
END_PRODUCTION

BEGIN_PRODUCTION(PRODUCTION_NID)
    parser::id.clear();
    REQUIRE_TERMINAL(TID)
    parser::id += tokens[ILC::offset - 1].value;
    while (TRY_REQUIRE_TERMINAL(TDOT))
    {
        REQUIRE_TERMINAL_CALLBACK(TID, EXPECTED("identifier"))
        parser::id += "."  + tokens[ILC::offset - 1].value;
    }
END_PRODUCTION

BEGIN_BINDINGS
BEGIN_SYMBOL_BINDING(NOR_VAL)
            PRODUCTION_NVAL_OR_VALUE()
        END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NAND_VAL)
            PRODUCTION_NVAL_AND_VALUE()
        END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NSUFFIX_VAL_NTERNARY)
            PRODUCTION_NSUFFIX_VAL_NTERNARY()
        END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NSUFFIX_ASGN)
            PRODUCTION_NASGN_SUFFIX()
        END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NYIELD)
            PRODUCTION_NYIELD()
        END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NRETURN)
           PRODUCTION_NRETURN()
        END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NID)
           PRODUCTION_NID()
        END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NTYPE)
           PRODUCTION_NTYPE()
        END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NVARIABLE_DEFINITION)
            PRODUCTION_NVARIABLE_DEFINITION()
        END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NCONST_DEFINITION)
            PRODUCTION_NCONST_DEFINITION()
        END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NSUFFIX_VAR_CONST_DEFINITION)
            PRODUCTION_NSUFFIX_VAR_CONST_DEFINITION()
        END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NSUFFIX_FUNCTION_CALL)
            PRODUCTION_NSUFFIX_FUNCTION_CALL()
        END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NSTAT)
            PRODUCTION_NVARIABLE_DEFINITION() or
            PRODUCTION_NCONST_DEFINITION() or
            PRODUCTION_NIF() or
            PRODUCTION_NFOR() or
            PRODUCTION_NWHILE() or
            PRODUCTION_NYIELD() or
            PRODUCTION_NFUNCTION() or
           PRODUCTION_NSTAT_FROM_VAL_or_ASGN_or_OR_or_AND()
        END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NVAL)
        (PRODUCTION_NVAL_PREFIX_VAL() and
            (PRODUCTION_NVAL_SLASH_VALUE() or
                PRODUCTION_NVAL_TIMES_VALUE() or
                PRODUCTION_NVAL_PLUS_VAL() or
                PRODUCTION_NVAL_MINUS_VALUE() or
                PRODUCTION_NVAL_GREATER_VALUE() or
                PRODUCTION_NVAL_GREATER_OR_EQUAL_VALUE() or
                PRODUCTION_NVAL_LOWER_VALUE() or
                PRODUCTION_NVAL_LOWER_OR_EQUAL_VALUE() or
                PRODUCTION_NVAL_EQUAL_VALUE() or
                PRODUCTION_NVAL_NOT_EQUAL_VALUE() or
                PRODUCTION_NVAL_NOT_VAL() or
                PRODUCTION_NVAL_AND_VALUE() or
                PRODUCTION_NVAL_OR_VALUE() or
                PRODUCTION_NSUFFIX_FUNCTION_CALL() or
                true)
        ) and PRODUCTION_ENDLESS_SUFFIXES()
        END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NSINGLE_VAL_PREDICATE)
            PRODUCTION_NVAL_NOT_VAL() or
            PRODUCTION_NVAL_AS_NUM() or
            PRODUCTION_NVAL_AS_CHAR_ARRAY() or
        (PRODUCTION_NVAL_AS_ID() and (PRODUCTION_NSUFFIX_FUNCTION_CALL() or true)) or
            PRODUCTION_NVAL_BOOLEAN() or
            PRODUCTION_NVAL_WITH_PARENTHESIS()
        END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NSINGLE_VAL)
            PRODUCTION_NSINGLE_VAL()
        END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NSEVENTH_PRIORITY_RHS_VAL)
        (PRODUCTION_NVAL_PREFIX_VAL() and (
            PRODUCTION_NVAL_TIMES_VALUE() or
            PRODUCTION_NVAL_SLASH_VALUE() or
            PRODUCTION_NVAL_PLUS_VAL() or
            PRODUCTION_NVAL_MINUS_VALUE() or
            PRODUCTION_NVAL_LOWER_VALUE() or
            PRODUCTION_NVAL_LOWER_OR_EQUAL_VALUE() or
            PRODUCTION_NVAL_GREATER_OR_EQUAL_VALUE() or
            PRODUCTION_NVAL_GREATER_VALUE() or
            PRODUCTION_NVAL_EQUAL_VALUE() or
            PRODUCTION_NVAL_NOT_EQUAL_VALUE() or
            PRODUCTION_NVAL_AND_VALUE() or
            PRODUCTION_NVAL_OR_VALUE() or
            true))
    END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NSIXTH_PRIORITY_RHS_VAL)
        (PRODUCTION_NVAL_PREFIX_VAL() and (
            PRODUCTION_NVAL_TIMES_VALUE() or
            PRODUCTION_NVAL_SLASH_VALUE() or
            PRODUCTION_NVAL_PLUS_VAL() or
            PRODUCTION_NVAL_MINUS_VALUE() or
            PRODUCTION_NVAL_LOWER_VALUE() or
            PRODUCTION_NVAL_LOWER_OR_EQUAL_VALUE() or
            PRODUCTION_NVAL_GREATER_OR_EQUAL_VALUE() or
            PRODUCTION_NVAL_GREATER_VALUE() or
            PRODUCTION_NVAL_EQUAL_VALUE() or
            PRODUCTION_NVAL_NOT_EQUAL_VALUE() or
            PRODUCTION_NVAL_AND_VALUE() or
            true))
      END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NFIFTH_PRIORITY_RHS_VAL)
        (PRODUCTION_NVAL_PREFIX_VAL() and (
            PRODUCTION_NVAL_TIMES_VALUE() or
            PRODUCTION_NVAL_SLASH_VALUE() or
            PRODUCTION_NVAL_PLUS_VAL() or
            PRODUCTION_NVAL_MINUS_VALUE() or
            PRODUCTION_NVAL_LOWER_VALUE() or
            PRODUCTION_NVAL_LOWER_OR_EQUAL_VALUE() or
            PRODUCTION_NVAL_GREATER_OR_EQUAL_VALUE() or
            PRODUCTION_NVAL_GREATER_VALUE() or
            PRODUCTION_NVAL_EQUAL_VALUE() or
            PRODUCTION_NVAL_NOT_EQUAL_VALUE() or
            true))
      END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NFOURTH_PRIORITY_RHS_VAL)
        (PRODUCTION_NVAL_PREFIX_VAL() and (
            PRODUCTION_NVAL_TIMES_VALUE() or
            PRODUCTION_NVAL_SLASH_VALUE() or
            PRODUCTION_NVAL_PLUS_VAL() or
            PRODUCTION_NVAL_MINUS_VALUE() or
            PRODUCTION_NVAL_LOWER_VALUE() or
            PRODUCTION_NVAL_LOWER_OR_EQUAL_VALUE() or
            PRODUCTION_NVAL_GREATER_OR_EQUAL_VALUE() or
            PRODUCTION_NVAL_GREATER_VALUE() or
            true))
      END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NTHIRD_PRIORITY_RHS_VAL)
        (PRODUCTION_NVAL_PREFIX_VAL() and (
            PRODUCTION_NVAL_TIMES_VALUE() or
            PRODUCTION_NVAL_SLASH_VALUE() or
            true))
      END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NSECOND_PRIORITY_RHS_VAL)
        (PRODUCTION_NVAL_PREFIX_VAL() and (
            PRODUCTION_NVAL_TIMES_VALUE() or
            PRODUCTION_NVAL_SLASH_VALUE() or
            PRODUCTION_NVAL_PLUS_VAL() or
            true))
      END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NFIRST_PRIORITY_RHS_VAL)
        (PRODUCTION_NVAL_PREFIX_VAL() and (
            PRODUCTION_NVAL_TIMES_VALUE() or
            PRODUCTION_NVAL_SLASH_VALUE() or
            true))
      END_SYMBOL_BINDING

BEGIN_SYMBOL_BINDING(NSUFIXED_VAL)
          PRODUCTION_NVAL_SLASH_VALUE() or
          PRODUCTION_NVAL_TIMES_VALUE() or
          PRODUCTION_NVAL_PLUS_VAL() or
          PRODUCTION_NVAL_MINUS_VALUE() or
          PRODUCTION_NVAL_GREATER_VALUE() or
          PRODUCTION_NVAL_GREATER_OR_EQUAL_VALUE() or
          PRODUCTION_NVAL_LOWER_VALUE() or
          PRODUCTION_NVAL_LOWER_OR_EQUAL_VALUE() or
          PRODUCTION_NVAL_EQUAL_VALUE() or
          PRODUCTION_NVAL_NOT_EQUAL_VALUE() or
          PRODUCTION_NVAL_NOT_VAL() or
          PRODUCTION_NVAL_AND_VALUE() or
          PRODUCTION_NVAL_OR_VALUE() or
          PRODUCTION_NSUFFIX_VAL_NTERNARY()
        END_SYMBOL_BINDING
END_BINDINGS

END_ILC_CODEGEN

inline bool parse()
{
    ILC::compilation_id++;
    ILC::offset = 0;
    META_PRODUCTION_STAT();
    return ILC::offset == ILC::chain_size;
}

// }
